AWSTemplateFormatVersion: '2010-09-09'
Description: 'Mila''s World - Maximum Security Private Deployment'

Parameters:
  DomainName:
    Type: String
    Default: 'mila.terrellflautt.com'
    Description: 'The subdomain for the site'

  Web3FormsAccessKey:
    Type: String
    Default: 'eafc242f-6c42-4d16-9253-28c7b6969aa7'
    NoEcho: true
    Description: 'Web3Forms access key'

  EmailTo:
    Type: String
    Default: 'terrell.flautt@gmail.com'
    Description: 'Email address for notifications'

  FlamingoPasswordHash:
    Type: String
    Default: 'b8c5a6e5f3d4a2b1c9e8f7a6b5c4d3e2'  # SHA-256 hash of "flamingo" - you should change this
    NoEcho: true
    Description: 'SHA-256 hash of the security gate password'

Resources:
  # ==========================================
  # S3 BUCKET - COMPLETELY PRIVATE
  # ==========================================
  PrivateContentBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${DomainName}-private-content'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldVersions
            Status: Enabled
            NoncurrentVersionExpirationInDays: 30
      Tags:
        - Key: Project
          Value: MilasWorld
        - Key: Security
          Value: Private

  # S3 Bucket Policy - ONLY CloudFront OAI can access
  PrivateContentBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref PrivateContentBucket
      PolicyDocument:
        Statement:
          - Sid: AllowCloudFrontOAI
            Effect: Allow
            Principal:
              CanonicalUser: !GetAtt CloudFrontOAI.S3CanonicalUserId
            Action: 's3:GetObject'
            Resource: !Sub '${PrivateContentBucket.Arn}/*'
          - Sid: DenyInsecureTransport
            Effect: Deny
            Principal: '*'
            Action: 's3:*'
            Resource:
              - !GetAtt PrivateContentBucket.Arn
              - !Sub '${PrivateContentBucket.Arn}/*'
            Condition:
              Bool:
                'aws:SecureTransport': false

  # CloudFront Origin Access Identity
  CloudFrontOAI:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub 'OAI for ${DomainName}'

  # ==========================================
  # DYNAMODB TABLE - ENCRYPTED
  # ==========================================
  AnswersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: 'milas-world-answers'
      BillingMode: PAY_PER_REQUEST
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: 'visitorId'
          AttributeType: 'S'
        - AttributeName: 'timestamp'
          AttributeType: 'S'
      KeySchema:
        - AttributeName: 'visitorId'
          KeyType: 'HASH'
        - AttributeName: 'timestamp'
          KeyType: 'RANGE'
      TimeToLiveSpecification:
        Enabled: false
      Tags:
        - Key: Project
          Value: MilasWorld
        - Key: DataClassification
          Value: Private

  # ==========================================
  # LAMBDA EXECUTION ROLE
  # ==========================================
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:PutItem'
                  - 'dynamodb:GetItem'
                  - 'dynamodb:Query'
                Resource: !GetAtt AnswersTable.Arn

  # ==========================================
  # LAMBDA FUNCTIONS
  # ==========================================
  AnswerHandlerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'milas-world-answer-handler'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_NAME: !Ref AnswersTable
          WEB3FORMS_ACCESS_KEY: !Ref Web3FormsAccessKey
          EMAIL_TO: !Ref EmailTo
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { PutItemCommand } = require('@aws-sdk/client-dynamodb');
          const https = require('https');

          const dynamodb = new DynamoDBClient({ region: process.env.AWS_REGION });

          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',
              'Access-Control-Allow-Methods': 'OPTIONS,POST',
              'Content-Type': 'application/json'
            };

            if (event.httpMethod === 'OPTIONS') {
              return { statusCode: 200, headers, body: '' };
            }

            try {
              const body = JSON.parse(event.body);
              const timestamp = new Date().toISOString();

              // Store in DynamoDB with encryption at rest
              await dynamodb.send(new PutItemCommand({
                TableName: process.env.TABLE_NAME,
                Item: {
                  visitorId: { S: body.visitorId || 'anonymous' },
                  timestamp: { S: timestamp },
                  questionId: { S: body.questionId || 'unknown' },
                  answer: { S: body.answer || '' },
                  puzzle: { S: body.puzzle || '' },
                  metadata: { S: JSON.stringify(body) }
                }
              }));

              // Send email via Web3Forms
              const emailData = {
                access_key: process.env.WEB3FORMS_ACCESS_KEY,
                subject: `New Answer from Mila's World - ${body.questionId}`,
                from_name: "Mila's World",
                to: process.env.EMAIL_TO,
                message: `
  Question: ${body.questionId}
  Puzzle: ${body.puzzle}
  Answer: ${body.answer}

  Timestamp: ${timestamp}
  Visitor: ${body.visitorId || 'anonymous'}
                `
              };

              await sendWeb3FormsEmail(emailData);

              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ success: true, message: 'Answer stored' })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ success: false, error: 'Internal error' })
              };
            }
          };

          function sendWeb3FormsEmail(data) {
            return new Promise((resolve, reject) => {
              const postData = JSON.stringify(data);
              const options = {
                hostname: 'api.web3forms.com',
                port: 443,
                path: '/submit',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(postData)
                }
              };

              const req = https.request(options, (res) => {
                let body = '';
                res.on('data', (chunk) => body += chunk);
                res.on('end', () => resolve(body));
              });

              req.on('error', reject);
              req.write(postData);
              req.end();
            });
          }

  DateRequestHandlerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'milas-world-date-request-handler'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_NAME: !Ref AnswersTable
          WEB3FORMS_ACCESS_KEY: !Ref Web3FormsAccessKey
          EMAIL_TO: !Ref EmailTo
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { PutItemCommand } = require('@aws-sdk/client-dynamodb');
          const https = require('https');

          const dynamodb = new DynamoDBClient({ region: process.env.AWS_REGION });

          exports.handler = async (event) => {
            const headers = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type',
              'Access-Control-Allow-Methods': 'OPTIONS,POST',
              'Content-Type': 'application/json'
            };

            if (event.httpMethod === 'OPTIONS') {
              return { statusCode: 200, headers, body: '' };
            }

            try {
              const body = JSON.parse(event.body);
              const timestamp = new Date().toISOString();

              await dynamodb.send(new PutItemCommand({
                TableName: process.env.TABLE_NAME,
                Item: {
                  visitorId: { S: body.visitorId || 'anonymous' },
                  timestamp: { S: timestamp },
                  questionId: { S: 'date-request' },
                  answer: { S: JSON.stringify(body) },
                  puzzle: { S: 'date-request' },
                  metadata: { S: JSON.stringify(body) }
                }
              }));

              const emailData = {
                access_key: process.env.WEB3FORMS_ACCESS_KEY,
                subject: 'ðŸ’• DATE REQUEST FROM MILA! ðŸ’•',
                from_name: "Mila's World",
                to: process.env.EMAIL_TO,
                message: formatDateRequest(body, timestamp)
              };

              await sendWeb3FormsEmail(emailData);

              return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ success: true })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ success: false, error: 'Internal error' })
              };
            }
          };

          function formatDateRequest(data, timestamp) {
            return `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   ðŸ’• DATE REQUEST FROM MILA! ðŸ’•   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WHEN: ${data.urgency || 'Not specified'}
WHERE: ${data.place || 'Surprise me'}
DATE: ${data.date || 'Flexible'}
TIME: ${data.time || 'Anytime'}

NOTE:
${data.note || 'No note'}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Submitted: ${timestamp}
            `;
          }

          function sendWeb3FormsEmail(data) {
            return new Promise((resolve, reject) => {
              const postData = JSON.stringify(data);
              const options = {
                hostname: 'api.web3forms.com',
                port: 443,
                path: '/submit',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(postData)
                }
              };

              const req = https.request(options, (res) => {
                let body = '';
                res.on('data', (chunk) => body += chunk);
                res.on('end', () => resolve(body));
              });

              req.on('error', reject);
              req.write(postData);
              req.end();
            });
          }

  # ==========================================
  # API GATEWAY - PRIVATE
  # ==========================================
  ApiGateway:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: 'milas-world-api'
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins:
          - !Sub 'https://${DomainName}'
        AllowMethods:
          - GET
          - POST
          - OPTIONS
        AllowHeaders:
          - Content-Type
          - X-Amz-Date
          - Authorization
          - X-Api-Key
        MaxAge: 300

  ApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref ApiGateway
      StageName: prod
      AutoDeploy: true

  # Lambda integrations
  AnswerIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt AnswerHandlerFunction.Arn
      PayloadFormatVersion: '2.0'

  DateRequestIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt DateRequestHandlerFunction.Arn
      PayloadFormatVersion: '2.0'

  # API Routes
  AnswerRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /answer'
      Target: !Sub 'integrations/${AnswerIntegration}'

  DateRequestRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /date-request'
      Target: !Sub 'integrations/${DateRequestIntegration}'

  # Lambda permissions for API Gateway
  AnswerHandlerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AnswerHandlerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  DateRequestHandlerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DateRequestHandlerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  # ==========================================
  # CLOUDFRONT DISTRIBUTION - HTTPS ONLY
  # ==========================================
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        HttpVersion: http2
        PriceClass: PriceClass_100
        Comment: !Sub 'Private distribution for ${DomainName}'
        Aliases:
          - !Ref DomainName
        ViewerCertificate:
          AcmCertificateArn: !Ref Certificate
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1.2_2021
        DefaultRootObject: index.html
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt PrivateContentBucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${CloudFrontOAI}'
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
          Compress: true
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          MinTTL: 0
          DefaultTTL: 86400
          MaxTTL: 31536000
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 404
            ResponsePagePath: /index.html
          - ErrorCode: 404
            ResponseCode: 404
            ResponsePagePath: /index.html
        Restrictions:
          GeoRestriction:
            RestrictionType: none

  # SSL Certificate (must be in us-east-1 for CloudFront)
  Certificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Ref DomainName
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Ref DomainName
          HostedZoneId: !Ref HostedZone

  # Route 53 Hosted Zone
  HostedZone:
    Type: AWS::Route53::HostedZone
    Properties:
      Name: terrellflautt.com
      HostedZoneConfig:
        Comment: 'Hosted zone for terrellflautt.com'

  # DNS Record for subdomain
  DNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZone
      Name: !Ref DomainName
      Type: A
      AliasTarget:
        DNSName: !GetAtt CloudFrontDistribution.DomainName
        HostedZoneId: Z2FDTNDATAQYW2  # CloudFront hosted zone ID

Outputs:
  BucketName:
    Description: 'S3 bucket name for uploading content'
    Value: !Ref PrivateContentBucket
    Export:
      Name: !Sub '${AWS::StackName}-BucketName'

  CloudFrontDistributionId:
    Description: 'CloudFront distribution ID for cache invalidation'
    Value: !Ref CloudFrontDistribution
    Export:
      Name: !Sub '${AWS::StackName}-DistributionId'

  CloudFrontDomain:
    Description: 'CloudFront distribution domain'
    Value: !GetAtt CloudFrontDistribution.DomainName

  SiteURL:
    Description: 'Website URL'
    Value: !Sub 'https://${DomainName}'

  ApiEndpoint:
    Description: 'API Gateway endpoint'
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Export:
      Name: !Sub '${AWS::StackName}-ApiEndpoint'

  DynamoDBTableName:
    Description: 'DynamoDB table name'
    Value: !Ref AnswersTable

  SecurityNote:
    Description: 'Security configuration'
    Value: 'S3 bucket is PRIVATE - only accessible via CloudFront OAI. DynamoDB encrypted at rest. HTTPS only.'
